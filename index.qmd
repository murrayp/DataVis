---
title: "Data display"
author: "PM"
filters:
  - shinylive
---



## App for data exploration (will show in meeting)

::: {#fig-dataexplore}
```{shinylive-python}
#| standalone: true
#| components: [viewer]
#| viewerHeight: 2000

from shiny import App, Inputs, Outputs, Session, render, ui
from shiny import reactive

import numpy as np
import pandas as pd
from pathlib import Path
import matplotlib.pyplot as plt
from scipy import stats
import seaborn as sns


my_file = Path(__file__).parent / "SamplePointsMasterFrame.csv"
df = pd.read_csv(my_file)

title_str=['time_point',
                      'som_width',
                       'som_length',
                       'som_area',
                       'som_ecc',
                        'amplitude', 
                      'signal_peaks',
                      'signal_troughs',
                      'period','sample_ind','cell_type','n_experiment','time_increasing_fl','time_decreasing_fl','power','kymo_slope']                     
selectedn_dict_fudge={'n1': 1.0, 'n2': 2.0,'n4': 4.0, 'n5': 5.0,'n6': 6.0,'n7':7.0}
selectedcell_type_fudge={'D5': 'D5', 'E5': 'E5','Hes7': 'Hes7'}
cell_type_colour_dict={'D5':'m', 'E5':'r','Hes7':'b'}
expn_markerdict={'n1':'x','n2':'o','n4': '+','n5': '^','n6':'.','n7':'>'}


app_ui = ui.page_fluid(
    ui.layout_sidebar(
        ui.panel_sidebar(ui.input_select(id="x",label="Variable",choices=title_str,selected=["signal_troughs"]),
            ui.input_select(id="y", label="Variable2",choices=title_str,selected=["period"]),
            ui.input_checkbox_group(
        "selectedcelltype",
        " Cell type(s):",
        {
            "D5": ui.span("D5", style="color: #121111;"),
            "E5": ui.span("E5", style="color: #ff0000;"),
            "Hes7": ui.span("Hes7", style="color: #0000FF;"),
        },
        selected=["D5","E5"]
    ),
    ui.input_checkbox_group(
        "selectedn",
        " n(s):",
        {
            "n1": ui.span("n=1"+expn_markerdict['n1'], style="color: #111112;"),
            "n2": ui.span("n=2"+expn_markerdict['n2'], style="color: #111112;"),
            "n4": ui.span("n=4"+expn_markerdict['n4'], style="color: #111112;"),
            "n5": ui.span("n=5"+expn_markerdict['n5'], style="color: #111112;"),
            "n6": ui.span("n=6"+expn_markerdict['n6'], style="color: #111112;"),
            "n7": ui.span("n=7"+expn_markerdict['n7'], style="color: #111112;"),


        },
        selected=["n1","n2","n4","n5","n6","n7"]
    ),
    ui.input_select(id="raw_or_z", label="Raw/Z score",choices=['Raw', 'Z score'],selected=["Raw"]),
    ui.input_radio_buttons(id='average_ns',label="Average within n",choices=['All data','Average within n'],selected='All data'),
    ui.input_slider(id="period_max",label="Max period filter",min=3.0,max=7.0,value=[3.5,5.5],step=0.1,drag_range=True),
    ui.input_slider(id="som_init_len",label="Som initial length",min=100.0,max=800.0,value=[120.1,700],step=5.0),           
    ui.input_slider(id="t_max",label="Samp. time max",min=0.0,max=17.0,value=[0.0,17.0],step=0.1),            
    ui.input_slider(id="amp_min",label="Amp min",min=0.0,max=100.0,value=20,step=0.05),     
    ui.input_slider(id="power_min",label="Power min",min=0.0,max=3.0,value=0.135,step=0.01), 
    ui.input_slider(id="kymo_slope",label="kymo_slope",min=-3.0,max=45.0,value=[0.0,32.0],step=1),  
    ui.input_file(id='input_file',label='Input file'),
            ),
        ui.panel_main(ui.output_plot("plot"),),
    ),
    
)


def server(input, output, session):
    
  @render.plot
  def plot():
    def parsed_file():
      file: list[FileInfo] | None = input.input_file()
      if file is None:
          return pd.DataFrame()
      return pd.read_csv(  # pyright: ignore[reportUnknownMemberType]
file[0]["datapath"]
      )
    fig, ax = plt.subplots(4,1,figsize=(32,10))
    #ax.set_ylim([-2, 2])
    # Filter fata
    global df


    if input.input_file():
      df = parsed_file()


    locdf=df
    locdf=locdf[title_str]

    title_str_num=['time_point',
                  'som_width',
                    'som_length',
                    'som_area',
                    'som_ecc',
                    'amplitude', 
                  'signal_peaks',
                  'signal_troughs',
                  'period',
                  'time_increasing_fl',
                  'time_decreasing_fl','power','kymo_slope']               

    period_min=input.period_max()[0]
    period_max=input.period_max()[1]
    som_length_min=input.som_init_len()[0]
    som_length_max=input.som_init_len()[1]
    t_min=input.t_max()[0]
    t_max=input.t_max()[1]

    kymo_slope_min=input.kymo_slope()[0]
    kymo_slope_max=input.kymo_slope()[1]
    power_min=input.power_min()
    amp_min=input.amp_min()
    selectedcelltype=input.selectedcelltype()
    selectedn=input.selectedn()
    selected_n_items=[]
    for i1 in range(len(selectedn)):
      selected_n_items.append(selectedn_dict_fudge[selectedn[i1]])
    
    selected_c_items=[]
    for i1 in range(len(selectedcelltype)):
      selected_c_items.append(selectedcell_type_fudge[selectedcelltype[i1]])  
    

    
    # Select subset of data based on filter criteria
    locdf=locdf[(locdf["period"]<period_max)&(locdf["period"]>period_min)&(locdf["som_length"]>som_length_min)&(locdf["time_point"]>=t_min)&(locdf["time_point"]<=t_max)&(locdf['n_experiment'].isin(selected_n_items))&(locdf['cell_type'].isin(selected_c_items))&(locdf['power']>power_min)&(locdf['amplitude']>amp_min)&(locdf['kymo_slope']>=kymo_slope_min)&(locdf['kymo_slope']<=kymo_slope_max)]


    if input.raw_or_z()=='Z score':
      # Find all data for a given n
      for n_sel in selectedn:
        for col in title_str_num:
          data_n_c=np.array((locdf[col].loc[locdf['n_experiment']==selectedn_dict_fudge[n_sel]]).copy())
          if len(data_n_c)>2:
            data_n_c=data_n_c.astype(float)

            z_score_data=(data_n_c-np.nanmedian(data_n_c))/stats.median_abs_deviation(data_n_c,nan_policy='omit')
            locdf.loc[locdf['n_experiment']==selectedn_dict_fudge[n_sel],col]=z_score_data 
    
    
    # if average over all ns
    x=locdf[input.x()]
    y=locdf[input.y()]
    cell_type=locdf["cell_type"]
    n=locdf["n_experiment"]
    sample_ind=locdf["sample_ind"]

    
    if input.average_ns()=='Average within n':
      df_avn=pd.DataFrame({'sample_ind': -1},index=[-1])
      row_index=0
      for sel_c_t in selectedcelltype:
        for n_sel in selectedn:
          dixt_add={}
          for col in title_str_num:
            data_point=((locdf[col].loc[(locdf['n_experiment']==selectedn_dict_fudge[n_sel])&(locdf['cell_type']==selectedcell_type_fudge[sel_c_t])])).median()
            if np.isnan(data_point)==False:
              dixt_add[col]=data_point
            #else:
            #  dixt_add[col]=-100.0

          dixt_add['cell_type']=selectedcell_type_fudge[sel_c_t]
          dixt_add['n_experiment']=selectedn_dict_fudge[n_sel]
          dixt_add['sample_ind']=float(row_index)
          
          new_row = pd.Series(dixt_add)
          df_avn=pd.concat([df_avn, new_row.to_frame().T],ignore_index=True)            
          row_index=row_index+1
      
      #df_avn = df_avn.drop(df_avn[df_avn['sample_ind'] == -1].index)
      locdf=df_avn

    
    exp_count=np.nan*np.ones((len(selectedn),len(selectedcelltype)))

    for cell_type_ind,sel_c_t in enumerate(selectedcelltype):
      for exp_ind,n_sel in enumerate(selectedn):
        data_n_c=locdf.loc[(locdf['n_experiment']==selectedn_dict_fudge[n_sel])&(locdf['cell_type']==selectedcell_type_fudge[sel_c_t])]
        
        exp_count[exp_ind,cell_type_ind]=len(data_n_c.to_numpy())

        x_select=data_n_c[input.x()]
        y_select=data_n_c[input.y()]

      
        ax[0].scatter(x_select,y_select,color=cell_type_colour_dict[sel_c_t],marker=expn_markerdict[n_sel])

        plot_traj=1
        if plot_traj==1:
          for j1 in range(16):
            data_n_c_traj=locdf.loc[(locdf['n_experiment']==selectedn_dict_fudge[n_sel])&(locdf['cell_type']==selectedcell_type_fudge[sel_c_t])&(locdf['sample_ind']==j1)]
            
            ax[0].plot(data_n_c_traj[input.x()],data_n_c_traj[input.y()],color=cell_type_colour_dict[sel_c_t],alpha=0.1)

      ax[0].set_xlabel(input.x())
      ax[0].set_ylabel(input.y())
      ax[0].table(cellText=exp_count,rowLabels=selectedn,
                colLabels=selectedcelltype,
                loc='upper right',
                colWidths=[0.1] * len(selectedcelltype))
    
    x_ticks=ax[0].get_xticks()
    ax[0].set_xlim([x_ticks[0], x_ticks[-1]+(x_ticks[-1]-x_ticks[0])*0.3]) 
  
    
    
    cell_type_tick_mark=np.array(range(len(selectedcelltype)))
    pvalues_mat=np.nan*np.ones((len(selectedcelltype),len(selectedcelltype)))
    
    x_vals=[]
    selected_Exp=[selectedn_dict_fudge[k] for k in selectedn]
    for i,sel_c_t in enumerate(selectedcelltype):
      # pull data from data frame for given cell type
      x_vals_i=(locdf[input.x()].loc[(locdf['n_experiment'].isin(selected_Exp))&(locdf['cell_type']==selectedcell_type_fudge[sel_c_t])]).to_numpy(dtype=float)

      normality_p_val=stats.shapiro(x_vals_i)
      
      normality_p_val=round(normality_p_val.pvalue,4)
      #normality_p_val=0.01
      for j,sel_c_t_j in enumerate(selectedcelltype):
        x_vals_j=(locdf[input.x()].loc[(locdf['n_experiment'].isin(selected_Exp))&(locdf['cell_type']==selectedcell_type_fudge[sel_c_t_j])]).to_numpy(dtype=float)

        if i>j:
          p_value=stats.mannwhitneyu(x_vals_i, x_vals_j, alternative="two-sided").pvalue
          #p_value=0.005
          p_value=round(p_value,4)
          pvalues_mat[i,j]=p_value
        elif i==j:
          pvalues_mat[i,j]=normality_p_val
      x_vals.append(x_vals_i)
    
    color = [cell_type_colour_dict[j] for j in selectedcelltype] #["green", "White", "Red", "Yellow", "Green", "Grey"] 
    sns.set_palette(color) 
    sns.boxplot(x_vals,ax=ax[1])
    
    #linecolor=
    col_labels = selectedcelltype
    row_labels = selectedcelltype
    #plotting
    ax[1].table(cellText=pvalues_mat,
                colWidths=[0.1] * len(x_vals),
                rowLabels=row_labels,
                colLabels=col_labels,
                loc='upper right')
    ax[1].set_xlim([np.min(cell_type_tick_mark)-0.75, 3.0*np.max(cell_type_tick_mark)])             

    ax[1].set_title(input.x())
    ax[1].set_xticks(cell_type_tick_mark)
    ax[1].set_xticklabels(selectedcelltype)
    
    y_vals=[]
    for i,sel_c_t in enumerate(selectedcelltype):
      # pull data from data frame for given cell type
      y_vals_i=(locdf[input.y()].loc[(locdf['n_experiment'].isin(selected_Exp))&(locdf['cell_type']==selectedcell_type_fudge[sel_c_t])]).to_numpy(dtype=float)

      normality_p_val=stats.shapiro(y_vals_i)
      
      normality_p_val=round(normality_p_val.pvalue,4)
      #normality_p_val=0.01
      for j,sel_c_t_j in enumerate(selectedcelltype):
        y_vals_j=(locdf[input.y()].loc[(locdf['n_experiment'].isin(selected_Exp))&(locdf['cell_type']==selectedcell_type_fudge[sel_c_t_j])]).to_numpy(dtype=float)

        if i>j:
          p_value=stats.mannwhitneyu(y_vals_i, y_vals_j, alternative="two-sided").pvalue
          #p_value=0.005
          p_value=round(p_value,4)
          pvalues_mat[i,j]=p_value
        elif i==j:
          pvalues_mat[i,j]=normality_p_val
      y_vals.append(y_vals_i)
    
    color = [cell_type_colour_dict[j] for j in selectedcelltype] #["green", "White", "Red", "Yellow", "Green", "Grey"] 
    sns.set_palette(color) 
    sns.boxplot(y_vals,ax=ax[2])
    
    #linecolor=
    col_labels = selectedcelltype
    row_labels = selectedcelltype
    #plotting
    ax[2].table(cellText=pvalues_mat,
                colWidths=[0.1] * len(x_vals),
                rowLabels=row_labels,
                colLabels=col_labels,
                loc='upper right')
    ax[2].set_xlim([np.min(cell_type_tick_mark)-0.75, 3.0*np.max(cell_type_tick_mark)])             

    ax[2].set_title(input.y())
    ax[2].set_xticks(cell_type_tick_mark)
    ax[2].set_xticklabels(selectedcelltype)
  
    
    #E5_locdf.drop(columns=E5_locdf.columns[0], axis=1, inplace=True)
    #locdf.drop(columns=['n_experiment','cell_type'], axis=1, inplace=True)
    locdf.rename(columns=lambda x: x[:6], inplace=True) #this will truncate the column name. Then print the dataframe
  

    corr_mat=locdf.corr(numeric_only=True,method='spearman')
    mask = np.triu(np.ones_like(corr_mat)) 

    
    chart=sns.heatmap(corr_mat, annot=True,annot_kws={'size':6.25},cmap=sns.diverging_palette(20, 220, n=200),vmin=-1.0,vmax=1.0,ax=ax[3],cbar=False,yticklabels=True,mask=mask)
    ax[3].set_title('Pearson correlation')
    ax[3].set_xticklabels(chart.get_xticklabels(),rotation=75,fontsize=6.0)
    
    #ax[3].set_yticks(np.linspace(0,corr_mat.shape[0]))

    ax[3].set_yticklabels(chart.get_xticklabels(),fontsize=4.0)        
    
      

app = App(app_ui, server)


## file: SamplePointsMasterFrame.csv
,time_point,cell_type,n_experiment,som_width,som_length,PSM_length,amplitude,signal_peaks,period,signal_troughs,som_area,som_ecc,rel_amplitude,rel_troughs,rel_peaks,rel_period,sample_ind,time_decreasing_fl,time_increasing_fl,power,kymo_slope
0,3.6,Wibj2,1.0,187.530109334512,422.6930504725042,,1.973729821555833e-15,7.894919286223334e-16,6.200000000000001,-1.1842378929335002e-15,60692.71499130554,0.8961973949419874,,,,,1.0,0.6000000000000001,5.6000000000000005,0.0869827062231352,5.408163265306124


```

An app for exploring all the data.
:::